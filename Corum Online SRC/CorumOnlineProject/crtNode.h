//====================================================================================================//
//
// $Header: /cvsroot/DEVELOP_V1/CorumOnlineProject/crtNode.h,v 1.2 2005/02/04 02:41:49 hwoarang Exp $
//
//====================================================================================================//

//====================================================================================================//
#pragma once
//====================================================================================================//

//====================================================================================================//
#define IS_NULL(p)		(NULL == p ? TRUE : FALSE)
#define IS_NOT_NULL(p)	(NULL != p ? TRUE : FALSE)
//====================================================================================================//

//====================================================================================================//
/**
* \ingroup XEngineCore
*
* \version 0.1
*
* \date 2004-07-13
*
* \author iihito
* 
* \par Remarks :
* 트리구조를 유지해주는 클래스이다.
* \todo 
*
* \bug 
*
*/
template < typename Type >
class crtNode  
{
public:
	//======================================================================//
	/**
	* 객체 자신
	*/
	Type*	m_pMe;
	/**
	* 바로앞의 이웃객체
	*/
	Type*	m_pSiblingPrev;
	/**
	* 바로다음 이웃객체
	*/
	Type*	m_pSiblingNext;
	/**
	* 부모 객체
	*/
	Type*	m_pParent;
	/**
	* 자식 객체
	*/
	Type*	m_pChild;
	//======================================================================//

public:
	//======================================================================//
	/**
	* 이웃한 객체중 바로 앞의 것을 리턴한다.
	* \return 
	*/
	Type*	GetPrev() const;
	//======================================================================//

	//======================================================================//
	/**
	* 이웃한 객체중 바로 뒤의 것을 리턴한다.
	* \return 
	*/
	Type*	GetNext() const;
	//======================================================================//

	//======================================================================//
	/**
	* 부모객체를 리턴한다.
	* \return 
	*/
	Type*	GetParent() const;
	//======================================================================//

	//======================================================================//
	/**
	* 자식객체중 가장 앞의 것을 리턴한다. 
	* \return 
	*/
	Type*	GetChild() const;
	//======================================================================//

	//======================================================================//
	/**
	* 현재 노드가 이웃리스트중 가장 앞의것이라면 TRUE, 아니면 FALSE를 리턴
	* \return 
	*/
	bool	IsBegin() const;
	//======================================================================//

	//======================================================================//
	/**
	* 현재 노드가 이웃리스트중 가장 뒤의 것이라면 TRUE, 아니면 FALSE를 리턴
	* \return 
	*/
	bool	IsEnd() const;
	//======================================================================//

	//======================================================================//
	/**
	* 자식노드를 소유하고 있다면 TRUE
	* \return 
	*/
	bool	IsChild() const;
	//======================================================================//

	//======================================================================//
	/**
	* 부모에 속해있다면 TRUE
	* \return 
	*/
	bool	IsParent() const;
	//======================================================================//

	//======================================================================//
	/**
	* 이웃리스트중 가장 앞의 것을 리턴한다.
	* \return 
	*/
	Type*	GetBegin();
	//======================================================================//

	//======================================================================//
	/**
	* 이웃리스트중 가장 뒤의 것을 리턴한다.
	* \return 
	*/
	Type*	GetEnd();
	//======================================================================//

	//======================================================================//
	/**
	* ptr을 이웃리스트에 넣는데, 현재 노드의 바로 앞에 넣는다.
	* \param ptr 
	* \return 
	*/
	Type*	PushFront( Type* const ptr );
	//======================================================================//

	//======================================================================//
	/**
	* ptr을 이웃리스트에 넣는데, 현재 노드의 바로 뒤에 넣는다.
	* \param ptr 
	* \return 
	*/
	Type*	PushBack( Type* const ptr );
	//======================================================================//

	//======================================================================//
	/**
	* ptr을 현재 노드의 자식 리스트에 넣는다.
	* \param ptr 
	* \return 
	*/
	Type*	PushChild( Type* const ptr );
	//======================================================================//

	//======================================================================//
	/**
	* 바로앞의 노드를 리스트에서 뺀다
	*/
	void	PopFront();	
	//======================================================================//

	//======================================================================//
	/**
	* 바로뒤의 노드를 리스트에서 뺀다
	*/
	void	PopBack();
	//======================================================================//

	//======================================================================//
	/**
	* 현재 노드를 리스트에서 뺀다.
	*/
	void	Pop();
	//======================================================================//

	//======================================================================//
	/**
	* ptr이 자식의 리스트에서 존재한다면 리스트에서 빼낸다.
	* \param ptr 
	*/
	void	PopChild( Type* ptr );
	//======================================================================//

	//======================================================================//
	/**
	*
	*/
	void	SwapFront();
	//======================================================================//

	//======================================================================//
	/**
	*
	*/
	void	SwapBack();
	//======================================================================//

	//======================================================================//
	/**
	*
	* \return 
	*/
	crtNode();
	//======================================================================//
};
//====================================================================================================//

//====================================================================================================//
//====================================================================================================//
//
// $Header: /cvsroot/DEVELOP_V1/CorumOnlineProject/crtNode.h,v 1.2 2005/02/04 02:41:49 hwoarang Exp $
//
//====================================================================================================//

//====================================================================================================//
#pragma once
//====================================================================================================//

//======================================================================//
template< typename T >
T*	crtNode< T >::GetPrev() const
{
	return m_pSiblingPrev;
}

template< typename T >
T*	crtNode< T >::GetNext() const
{
	return m_pSiblingNext;
}

template< typename T >
T*	crtNode< T >::GetParent() const
{
	return m_pParent;
}

template< typename T >
T*	crtNode< T >::GetChild() const
{
	return m_pChild;
}
//======================================================================//

//======================================================================//
template< typename T >
bool	crtNode< T >::IsBegin() const
{
	return GetPrev() == NULL;
}

template< typename T >
bool	crtNode< T >::IsEnd() const
{
	return GetNext() == NULL;
}

template< typename Type >
bool	crtNode< Type >::IsChild() const
{
	return GetParent() != NULL;
}

template< typename Type >
bool	crtNode< Type >::IsParent() const
{
	return GetChild() != NULL;
}
//======================================================================//

//======================================================================//
template< typename T >
T*	crtNode< T >::GetBegin()
{
	if( IsBegin() )
		return this;

	T*	tmp = GetPrev();

	while( tmp->IsBegin() == FALSE )
		tmp = tmp->GetPrev();

	return tmp;
}

template< typename T >
T*	crtNode< T >::GetEnd()
{
	if( IsEnd() )
		return this;

	T*	tmp = GetNext();

	while( tmp->IsEnd() == FALSE )
		tmp = tmp->GetNext();

	return tmp;
}
//======================================================================//

//======================================================================//
template< typename T >
T*	crtNode< T >::PushFront( T* const ptr )
{
	if( IS_NULL(ptr) )
		return NULL;

	ptr->Pop();

	if( IsBegin() == FALSE )
	{
		GetPrev()->m_pSiblingNext = ptr;
		ptr->m_pSiblingPrev = GetPrev();
	}

	m_pSiblingPrev = ptr;
	ptr->m_pSiblingNext = m_pMe;

	if( IsChild() )
	{
		ptr->m_pParent = GetParent();
	}

	return m_pSiblingPrev->m_pSiblingPrev;
}

template< typename T >
T*	crtNode< T >::PushBack( T* const ptr )
{	
	if( IS_NULL(ptr) )
		return NULL;

	ptr->Pop();

	if( IsEnd() == FALSE )
	{
		GetNext()->m_pSiblingPrev = ptr;
		ptr->m_pSiblingNext = GetNext();
	}

	m_pSiblingNext = ptr;
	ptr->m_pSiblingPrev = m_pMe;

	if( IsChild() )
	{
		ptr->m_pParent = GetParent();
	}

	return m_pSiblingNext->m_pSiblingNext;
}

template< typename T >
T*	crtNode< T >::PushChild( T* const ptr )
{
	if( IS_NULL(ptr) )
		return NULL;

	if( IsParent() )
	{
		m_pChild->PushBack( ptr );
	}
	else
	{
		ptr->Pop();
		m_pChild = ptr;
		ptr->m_pParent = m_pMe;
	}

	return ptr;
}
//======================================================================//

//======================================================================//
template< typename T >
void crtNode< T >::PopFront()
{
	if( IsBegin() == FALSE )
	{
		GetPrev()->Pop();
	}
}

template< typename T >
void crtNode<T>::PopBack()
{
	if( IsEnd() == FALSE )
	{
		GetNext()->Pop();	
	}
}

template< typename T >
void	crtNode<T>::Pop()
{
	// 부모객체가 존재한다면 부모의 m_pChild를 바꿔줘야겠지.
	if( IsChild() )
	{
		// 부모가 소유한 자식리스트중에 자신이 head라면...
		if( GetParent()->GetChild() == this )
			GetParent()->m_pChild = GetParent()->GetChild()->GetNext();

		m_pParent = NULL;
	}

	// m_pPrevSibling이 존재하는, 즉 Head가 아니라면
	if( IsBegin() == FALSE )
	{
		GetPrev()->m_pSiblingNext = GetNext();	
		m_pSiblingPrev = NULL;
	}

	if( IsEnd() == FALSE )
	{
		GetNext()->m_pSiblingPrev = GetPrev();
		m_pSiblingNext = NULL;
	}	
}

template< typename T > 
void	crtNode< T >::PopChild( T* ptr )
{
	if( GetChild() == NULL || IS_NULL(ptr) )
		return;

	// 차일드 검색
	T*	pT = GetChild();

	while( pT != NULL && pT != ptr )
		pT = pT->GetNext();

	if( pT == ptr )
	{
		pT->Pop();
	}
}
//======================================================================//

//======================================================================//
template< typename T >
void	crtNode<T>::SwapFront()
{
	if( IsBegin() )
		return;

	T* pT = GetPrev();

	PopFront();
	PushBack( pT );
}

template< typename T >
void	crtNode<T>::SwapBack()
{
	if( IsEnd() )
		return;

	T* pT = GetNext();

	PopBack();
	PushFront( pT );
}
//======================================================================//

//======================================================================//
template< typename T >
crtNode<T>::crtNode() 
: m_pSiblingPrev(NULL), 
m_pSiblingNext(NULL),
m_pParent(NULL),
m_pChild(NULL)
{
	INT	iOffset = (INT)(T*)1 - (INT)(crtNode<T>*)(T*)1;
	m_pMe = (T*)((INT)this + iOffset);
}
//======================================================================//
//====================================================================================================//