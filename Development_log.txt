


TRIVIA::
 - the class `Effect`
   - contrary to its name it does not describe a visual effect / animation; it describes the properties of a skill



---------------------------------- TO DO -----------------------------------------------

 - DungeonServer: Effect.cpp l:365 + Client:: DungeonProcess.cpp l:948
   - seems like different formulas are used for the overdrive mana charge, should look into it [DONE]

- DungeonProcess.cpp :: l: 1037 
 - seems like the client computes the weight percentage & does a check on the limit; 
   - this info should come from the server, to be investigated;


- Client.EffectProcess.cpp :: 1574, seems like the client updates the HP based on the poison effect; 
    - should be done on the server


- Client.Effect.cpp l: 455 + DungeonProcess l: 939 
    - seems like the client is handling the cast speed logic ? [DONE, no more]


- User. m_dwExp :: represents the total accumulated EXP; (computing the correct level & scale of the xp bar should now be complete) [DONE]

- there's duplicate copies of CVoidList on each target, should be unified

- weight limit exceeded not correctly handled now; movement speed reduction not correctly applied

- inform visually when the cast fails because of not enough cool points; 
  + display the required coolpoints on each skill description [DONE]
    + display the user's current coolpoints numerically in the interface [hmm]

- fix the UI [mostly done]

- sorceress' "fast cast" overdrive doesnt seem to do anything, must look into it 

- often some textures are not loaded (helam, kuelgard, Kiabronte, etc..)
- drawing still has hiccups, in some areas it is even below 60fps; 

-------------------------------------- FINDINGS --------------------------------------------

- Skills + Cooldown points + time [To be investigated more]
  - player cool points seem to represent an amount in seconds, of "available cast time"

  + each skill has a "cool time" in milliseconds : Effect->BaseSkill->dwCoolTime ; 
    - this represents the animation duration;
      - generally there's a quick basic animation for most skills, but fighter & ranger have complex animation ; sorc and summoner have basic animations


    [OUTDATED]- the player should wait "dwCoolTime / 1000" seconds before casting the same skill again; i.e. wait for the current animation to finish
    [OUTDATED] - the last cast date( time in milliseconds) for each skill is stored in g_pMainPlayer->d_dwStartSkillTick and it used in checks



- CTDS_DUNGEON_CASTING + DSTC_DUNGEON_CASTING vs CTDS_SKILL + DSTC_SKILL

  CTDS_DUNGEON_CASTING
    - sent by the client when 
       - left or mouse button press event (DungeonProcess.SkillEvent(0 (left) || 1 (right)))
    + Processing done by the DungeonServer::
        + cond1: if the time since the last cast (g_dwTickCount - pUser->m_dwStartSkillTick[bSkillKind]) is less than the effect's cooldown time (pEffect->dwCoolTime)
          - check if you can 'substract' the effect's cooldown time(milliseconds) from the user's cooldown points(seconds)
            - int nCool = INT(pUser->m_fCurCoolPoint*1000 - pEffect->dwCoolTime); 
            - nCool < 0 ? fail the current skill cast, send packet about it; 
              else
                - pUser->m_fCurCoolPoint = max(nCool/1000.f, 0.1F) and continue;
              (===>the client shouldn't perform cooldown cost calculations, this value should be sent back by the dungeon server)
        + then recompute the user's min /max attack damages (CUser::GetAttackingDamage)
            - actually it only recomputes if the user's character is a ranger, case in which it adds maxSP() / 30 as a bonus damage; 
        + record the time(milliseconds) of the skill's :: 
           -- cast start time : into ``` pUser->m_dwTemp[USER_TEMP_CASTINGSTARTTICK] = g_dwTickCount;``
           -- cast end(?) time: into ``` pUser->m_dwTemp[USER_TEMP_CASTINGDESTTICK] = complicated formula;```
        + then build a ``DSTC_DUNGEON_CASTING`` with updated 3D positions of the target of the skill cast (if monster or player) or the 3d position of the tile (if not a targeted skill cast) and broadcast it back
          + the client receives this 'confirmation' packet but it only does some visual  updates on the 3d model of the caster + plays the skill sound, and thats it on


- CTDS_SKILL is sent by the client only if it's overdrive or (fighter) aura recharge; i.e. a continous skill
 + Also, 'sent' by the DungeonServer to itself during the periodic user update (ServerFunction.cpp :: ProcessDungeon :: CUser.Update()) if 
    ````
    			case UNIT_STATUS_CASTING:
				{
					if (g_dwTickCount > m_dwTemp[USER_TEMP_CASTINGDESTTICK] 
    ```` 
  - Processed by EffectLayer 
    - on each CTDS_SKILL event { pSkillDesc } ::
      + Process and find out the caster : GetCaster(pSkillDesc) 
        i.e. : 
          -  find out if the caster is a user or a monster or a user's monster
          - special handling when the caster is a user::
             - cond 1: check if the user is not dead (and if so he can only cast __TREEAGION__ (??)) and he is not in a village (IsUnitStatusReadySkill)
             - cond 2: about to do with skill level, basic integrity checks (skill level > 0 , < 255)
             - cond 3: something about user being in god mode, no idea what is that;
             - cond 4: if overdrive then check if there is an item in users inventory that allows it( free pass, taurus zodiac)
             - step: get the mana 'offset', to be added to the user's current mana points for using this skill;
                - mostly this value is negative except when the used skill is aura recharge; that skill actually gives mana
               - special computations:
                  - life explosion uses all of the mana, offset = -user.currentSP()
                  - overdrive has a complicated formula + it also updates the skill 'keepTime' based on the time passed since the skill cast (cast started at user->m_dwTemp[USER_TEMP_CASTINGSTARTTICK] (milliseconds)); let duration = time_now_milliseconds - user->m_dwTemp[USER_TEMP_CASTINGSTARTTICK];
                   - formula:: 
                        spOffset = user.maxSP() * 0.1 * (duration / 1000)
                        skillKeepTime = spOffset / skill.currentManaCost(based on its level, etc) * (weird ego formula) * 1000 (last *1000 probably to turn it into milliseconds)

           - returned offset either positive(if aura recharge) or negative
        - record the time for this current skill event, update the mana
          ```
        	  pOwnUser->m_dwStartSkillTick[pSkillDesc->bSkillKind] = g_dwTickCount;
	          pOwnUser->SetSP(pOwnUser->GetSP()+nMana);
          ```
        - then send a USER_STATUS update to the client; 
          ( this means that the client should not deal with computing the mana value at each cast 'step', 
            it will be returned back by the server in a USER_STATUS packet;
            [OK NOT TRUE ANYMORE] the client is responsible for sending CTDS_SKILL packets as long as the user keeps the mouse button pressed;
              - what actually should happen is, the client should lock the character into 'casting' position until the `DSTC_SKILL` confirmation packet arrives; even for overdrive skills;
                problems though:
                  - the status with the used sp comes only at the end; players are used to see their sp updated during the overdrive cast
                  -  USER_TEMP_CASTINGDESTTICK] = ... ; in the formula the SP value is not taken into consideration;
                   - seems like for overdrive the consumed sp is (0.1 * maxSP() * seconds since USER_TEMP_CASTINGSTARTTICK), defaulted to current sp if exceeding; 
                  - so in the 'R/L mouse button up' event  the client sends a 'CTDS_SKILL' packet, for the same skill;
                      - this will make the dungeon server instantly move into the 'processing phase' for the skill / i.e. not wait until USER_TEMP_CASTINGDESTTICK to process it; 
                      - the client makes sure to send this packet only for continous skills; [to be moved into the dungeon server]
                  - seems like OD skills have a casting time '0' , so there needs to be a different formula for them; 
          )
      + find the targets this skill applies to, process the applied skill (reduce the target hp, etc..); 
        - during this processing affected players's hp updates are sent with a USER_STATUS packet;
      + send back a DSTC_SKILL packet; it contains properties of the original packet + a list of targets the skill applied to 

      + the client processes the DSTC_SKILL packet by setting up the player model's motion change (from the casting animation to whatever animation depending on the skill) + the effect animation of that skill; EffectCommand.cpp :: CmdSkill

SKILL FLOW  :: RECAP
 - Client: L/R button press -> 
   -> Client: DungeonProcess::SkillEvent(0 || 1)
     -> Client: User.SetPacket*(skillUSer | skillMonster | skillTile)
        -> Client: User.SendCasting(): 
          :: client sends CTDS_DUNGEON_CASTING, sets unit status to UNIT_STATUS_CASTING

 -> DungeonServer: receives `CTDS_DUNGEON_CASTING` & processes it in `CmdDungeonSkillCasting`
   + check '''g_dwTickCount - pUser->m_dwStartSkillTick[bSkillKind] < pEffect->dwCoolTime''', update user's m_fCurCoolPoint property if so, 
   + if not a continous skill then update user's status to UNIT_STATUS_CASTING
   + update user's ``m_sCastingInfo`` with the  properties of the skill from the packet
   + re-update user's min/max damages (a.k.a if ranger add a bonus: maxSP() / 30)
   + update 
      ``` 
       	pUser->m_dwTemp[USER_TEMP_CASTINGSTARTTICK] = g_dwTickCount;
	      pUser->m_dwTemp[USER_TEMP_CASTINGDESTTICK] = DWORD(max(g_dwTickCount, etc...
      ```
   + create `confirmation` packet DSTC_DUNGEON_CASTING, with proper target positions and broadcast to all players in the layer

 -> Client: receives `DSTC_DUNGEON_CASTING` & process it in `EffectCommand.CmdSkillCasting`
  + basically updates the 3d model animation to MOTION_TYPE_CHARGE, plays the skill cast sound

----- time passes -----
 -> DungeonServer: CUser::Update() for all users
  + processing related to skill casting: (if UNIT_STATUS_CASTING && g_dwTickCount > m_dwTemp[USER_TEMP_CASTINGDESTTICK]) ::
    + create CTDS_SKILL , update it with the properties of the skill, from `m_sCastingInfo`
     -> DungeonServer: CmdSkill is called with it
      + augment it with more data, into a SKILL_DESC
      -> g_pEffectLayer->SendSkill(&skillDesc)::
        + call  ProcessCasterForSkillCast(pSkillDesc)
          -> ProcessUsersSkillCast((CUser*)pOffenseUnit, pSkillDesc))
            + basic skill cast integrity checks (
                not in a village, 
                not an invalid level, 
                has enough SP for it,
                if overdrive : has taurus or overdrive items in inventory,
                player not dead (or dead AND the cast skill is revive/treeagion))
            + pOwnUser->m_dwStartSkillTick[pSkillDesc->bSkillKind] = g_dwTickCount;
            + pOwnUser->SetSP(pOwnUser->GetSP() + manaOffset);
            + send DSTC_USER_STATUS with current sp points
        + find the number of targets this skill applies to, 
          for each target:
            + apply damage, update status and hp (where possible)
            + record the target
        + broadcast to all players a DSTC_SKILL packet, with the targets and skill properties
          -> Client: receives and processes it in `EffectCommand.cpp::CmdSkill`
            + call pOwnUser->SetActionSkill(bSkillKind);
              + sets the appropriate 3d character model's skill 'execution' animation (i.e. fighter and ranger have specific animations i.e. knife chain / lightining strike;)
              + creates and sets the 3d model & animation for the actual skill

SKILLing is comprised of two phases: 
 1. loading or 'cast' phase :: between USER_TEMP_CASTINGSTARTTICK and USER_TEMP_CASTINGDESTTICK
 2. 'execution'  phase :: starts from m_dwStartSkillTick[bSkillKind] (which should usually coincide with USER_TEMP_CASTINGDESTTICK)


[ USER_TEMP_CASTINGSTARTTICK (loading phase starts)
. 
. during this time the player 3d model is locked into the 'cast' animation
. 
.
[ USER_TEMP_CASTINGDESTTICK (loading phase ends)
[..]
[m_dwStartSkillTick[bSkillKind] (processing phase starts)
.
. during this time the skill is 'applied'  (i.e. find out the number of affected monsters/players, reduce their hp)
.
.
[pEffect[bSkillKind]->dwCoolTime (skill cooldown time ends, can be cast again)

[[-- and a new skill cast can happen again from this point
  -> so, if a user wants to cast a new skill instance (of the same skill) at a time during the cooldown of the previous instance, the cooldown time is substracted from the user's cooldown points]] \\[OUTDATED]


  
--------------------------------------------- 
  -> NEW IMPLEMENTATION

 :: the cooldown of the skill will be substracted from the user's cooldown points; 
      :: cooldown points are regenerated & updated every 0.5 seconds by the dungeon server
      :: the player has to put in EGO stats to increase the capacity of his cooldown points 
      [TO DO] :: must display on the skill description the required cooldown points cost (dwCoolTime) + show the user's cooldown points numerically somewhere in the interface
  [BUG]




================================================================

Dungeon Siege time (duration)
 + these properties seem to affect the times when the siege war is supposed to start + its duration: 
  - m_dwPieceCoolTime :: the time (in milliseconds) it takes for the product to complete one evolution step;
  - m_wBattleTimeLimit :: the time (in minutes) that a siege war is supposed to last;

  - after a siege war ends, i.e. at time T_lastWarEnd (milliseconds, CPU time) the next siege war will start at:
    - T_nextWarStart = T_lastWarEnd + [ m_dwPieceCoolTime - milliseconds(m_wBattleTimeLimit) ];
     i.e. 
       - if the product needs 30 minutes for one  evolution step 
       - the last siege war just ended now, with war duration =  10 minutes 
       - then the next siege war will start (from now) in 20 minutes 

    - in other words, siege wars always happen during a product evolution step
    + 
    - siege wars always end at a (m_dwPieceCoolTime) multiple . 
    
Dungeon Siege production
  + from what I recall, dungeons specify either a general range of products(i.e. `Bag`) or a specific product, (i.e. )

  + struct DUNGEONPRODUCTIONITEMMINMAX { 	BYTE	byID; WORD	wItemIDMin; WORD	wItemIDMax; WORD	wItemIDDefault; }
     + represents what a siege dungeon can produce;  
        itemIDMin - itemIDMax is probably the range of item ids from which it selects to produce the final output;
        wItemIDDefault - probably a placeholder value, ' 
  
  + there can only be a maximum of (#define		MAX_DUNGEON_PROPERTY 5) instances of this production data; 
   + it is stored in an array of rows retrieved from the [Corum0].[DungeonProductionItemMinMax] table in order
  + the dungeon data structs (worldserver, dungeonserver, client) all contain a `m_byProperty` which is an index into this array;
  + 'm_wProduction' (MapInfo.Production) is a dynamic property on the dungeon data subclasses representing the selected id from the item id range (or the default item id) 
    - when m_wProduction == wItemIDDefault it means the dungeon is in 'undecided product state' 
  + 'm_byProductionCount' (MapInfo.ProductionCount) dynamic property representing the current evolution step; in the range ([0, 3])




  + a siege dungeon can be in 3 states (`OperationType` in `MapInfo` table) {
    	DUNGEON_OPERATIONTYPE_PRECOCIOUS = 0,
	    DUNGEON_OPERATIONTYPE_PRODUCTION = 1,
	    DUNGEON_OPERATIONTYPE_CONVERSION = 2,
   }





 at the end of a siege war this mode + the evolution step can change: 
 seems like the order of state changes goes like this: (in case of a succesful defense, i.e. same owner before & after the war)
   0.1 decrease the quantity of its current attached magic field array item, if any

   1. if dungeon is in `undecided product state` with no evolution step i.e. (m_byProductionCount == 0 && m_wProduction == wItemIDDefault)
      => then increment the evolution step (m_byProductionCount = 1) 
        update mode to DUNGEON_OPERATIONTYPE_PRECOCIOUS

   2.  if dungeon is in `undecided product state` with one evolution step i.e. (m_byProductionCount == 1 && m_wProduction == wItemIDDefault)
      => then decide on what item to produce and reset the evolution (m_byProductionCount = 1; m_wProduction = decision())
      update mode to DUNGEON_OPERATIONTYPE_PRECOCIOUS

   3. if the production is decided 
    IF the dungeon is in DUNGEON_OPERATIONTYPE_CONVERSION
      ==> re-decide the production item id ; m_wProduction = decision()
    ELSE
     IF it has a magic field array attached
       => update mode to  DUNGEON_OPERATIONTYPE_CONVERSION
     ELSE 
     => if the mode is still DUNGEON_OPERATIONTYPE_PRECOCIOUS then increment the evolution step counter ( but not beyond 3)
     
     => if the evolution counter is at the final step (3)
         = > update mode to DUNGEON_OPERATIONTYPE_PRODUCTION

  ======= special case if the dungeon has a magic field array item property ===========
   - not really sure whats the deal with these, these items probably represnt a special buff applied to the siege dungeon
   --> if the dungeon has a magic field array attached, and the product is decided: 
      => update mode to DUNGEON_OPERATIONTYPE_CONVERSION , 
       -- meaning the item is produced instantly (no evolution steps increments) + it is re-decided / re-randomized on each siege war, regardless if the war was won or not


if the siege war was lost(i.e. different owner pre / post war)
 - apply a "regression"::
    - decrement the evolution step
    - if evolution step == 0 , "cancel" the production, m_wProduction = wItemIDDefault

regardless of whether it is a regression or an evolution , this updtae happens only if the siege has an owner; 



===================== ITEM CATEGORISATION ======================================
#define ITEM_DISTRIBUTE				200
#define	ITEM_WEAPONST_INDEX			0
#define	ITEM_WEAPONEND_INDEX		7
#define	ITEM_ARMORST_INDEX			10
#define	ITEM_ARMOREND_INDEX			17
#define ITEM_BAG_INDEX				18
#define	ITEM_GUARDIAN_INDEX			19
#define	ITEM_RIDE_INDEX				20
#define ITEM_MIXUPGRADEST_INDEX		31
#define ITEM_MIXUPGRADEEND_INDEX	33
#define ITEM_UPGRADE_INDEX			34
#define ITEM_LIQUID_INDEX			35
#define ITEM_EDITION_INDEX			36
#define	ITEM_ZODIAC_INDEX			40
#define	ITEM_SUPPLIES_INDEX			50
#define	ITEM_SPECIALST_INDEX		60
#define	ITEM_SPECIALEND_INDEX		66
#define ITEM_MATERIALST_INDEX		70
#define ITEM_MATERIALEND_INDEX		77
#define	ITEM_MAGICARRAY_INDEX		80
#define ITEM_MAGICFIELDARRAY_INDEX	90
#define ITEM_CONSUMABLEST_INDEX		101
#define ITEM_CONSUMABLEEND_INDEX	102
#define	ITEM_MONEY_INDEX			125

The 'category' of an item is int(itemID / ITEM_DISTRIBUTE)
but either there can be more than 200 items inside a category(?) or their ID's are not uniformly spread;  
the result must be compared to all intervals [_startIndex, _endIndex] defined above


===============================================
Pathfinding on worldmap vs dungeons ; client vs worldserver
 - a TTB file stores a matrix of values describing the layout of a 3d map floor (a dungeon floor or a worldmap) ; 
 - such maps are divided into tiles, if a tile is 'walkable' it has a specific value on its attribute field
   - one tile corresponds to a (currently) 80 x 80 (worldmap) / 125 x 125 (dungeon floor) region on the map ; 
     ==> that region's tile index into the ttb matrix is therefore ( line: z / tile_Size, column: x / tile_size)
   - BUT the 3D origin of a map is on the bottom-left corner  and the ttb file store data top-down 
      (i.e. tile data at [0, 0] corresponds to the 3d region starting at (x: 0, y: 0 (not used), z: maxZ) )
     =====> the correct index for a 3d(x, 0, z) region is therefore: 
           line:  (line_count - 1) -  z / tile_Size 
           column: x / tile_size 
            -- the client somehow takes this into account within its pathfinding utilities but the worldServer needed a fix for it

=========================================

CmdChangeLayer 
 -- is a mini - reinitialization during dungeon gameplay, for the new layer 
   -- but it may fuck up some things set up during 'InitGameDungeon' 
    -- (i.e. it deletes & re-sets g_pEffectLayer & other globals) 


================================
Dungeons and group IDs
  - basically used for passage dungeons, 
  - dungeons having the same 'groupID' all activate their 'hover' effect when the player hovers over any one of them



  ================================================
  Resources ::
    - .mod ===> 3D model
    - .anm ===> animation data for a 3D model (vertices, faces, material)
    - .chr =====> it combines a 3D model with an animation 
         ====> animations can be re-used between diffrent models
            ====> i.e. all dual costumes / character models  reuse the same walking, running ,attacking, etc... animations